{
  "_args": [
    [
      {
        "raw": "omriBernstein/tessel-av",
        "scope": null,
        "escapedName": null,
        "name": null,
        "rawSpec": "omriBernstein/tessel-av",
        "spec": "github:omribernstein/tessel-av",
        "type": "hosted",
        "hosted": {
          "type": "github",
          "ssh": "git@github.com:omribernstein/tessel-av.git",
          "sshUrl": "git+ssh://git@github.com/omribernstein/tessel-av.git",
          "httpsUrl": "git+https://github.com/omribernstein/tessel-av.git",
          "gitUrl": "git://github.com/omribernstein/tessel-av.git",
          "shortcut": "github:omribernstein/tessel-av",
          "directUrl": "https://raw.githubusercontent.com/omribernstein/tessel-av/master/package.json"
        }
      },
      "/Users/kresnik/Fullstack-Junior/theftCamera"
    ]
  ],
  "_from": "omribernstein/tessel-av",
  "_id": "tessel-av@0.15.0",
  "_inCache": true,
  "_location": "/tessel-av",
  "_phantomChildren": {},
  "_requested": {
    "raw": "omriBernstein/tessel-av",
    "scope": null,
    "escapedName": null,
    "name": null,
    "rawSpec": "omriBernstein/tessel-av",
    "spec": "github:omribernstein/tessel-av",
    "type": "hosted",
    "hosted": {
      "type": "github",
      "ssh": "git@github.com:omribernstein/tessel-av.git",
      "sshUrl": "git+ssh://git@github.com/omribernstein/tessel-av.git",
      "httpsUrl": "git+https://github.com/omribernstein/tessel-av.git",
      "gitUrl": "git://github.com/omribernstein/tessel-av.git",
      "shortcut": "github:omribernstein/tessel-av",
      "directUrl": "https://raw.githubusercontent.com/omribernstein/tessel-av/master/package.json"
    }
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "git://github.com/omribernstein/tessel-av.git#1be2dd0a5c28e14bdae852afca8d5df73f6907c3",
  "_shasum": "89764a460dd80342c340de37270e73c81756b292",
  "_shrinkwrap": null,
  "_spec": "omriBernstein/tessel-av",
  "_where": "/Users/kresnik/Fullstack-Junior/theftCamera",
  "author": {
    "name": "Rick Waldron",
    "email": "waldron.rick@gmail.com"
  },
  "bugs": {
    "url": "https://github.com/tessel/tessel-av/issues"
  },
  "contributors": [
    {
      "name": "Tim Cameron Ryan",
      "email": "<tim@technical.io"
    },
    {
      "name": "bellbind",
      "email": "<bellbind@gmail.com"
    }
  ],
  "dependencies": {
    "got": "^6.3.0",
    "ip": "^1.1.3",
    "tessel-mjpeg-consumer": "^1.1.0"
  },
  "description": "Cross-platform audio record/playback and video recording.",
  "devDependencies": {
    "common-tags": "^1.3.1",
    "grunt": "^1.0.1",
    "grunt-cli": "^1.2.0",
    "grunt-contrib-jshint": "^1.0.0",
    "grunt-contrib-nodeunit": "^1.0.0",
    "grunt-contrib-watch": "^1.0.0",
    "grunt-jsbeautifier": "^0.2.13",
    "grunt-jscs": "^3.0.1",
    "mkdirp": "^0.5.1",
    "sinon": "^1.14.1"
  },
  "gitHead": "1be2dd0a5c28e14bdae852afca8d5df73f6907c3",
  "homepage": "https://github.com/tessel/tessel-av#readme",
  "license": "MIT",
  "main": "lib/index.js",
  "name": "tessel-av",
  "optionalDependencies": {},
  "readme": "# tessel-av\n[![Code of Conduct](https://img.shields.io/badge/%E2%9D%A4-code%20of%20conduct-blue.svg?style=flat)](https://github.com/tessel/project/blob/master/CONDUCT.md)\n[![Travis Build Status](https://travis-ci.org/tessel/tessel-av.svg?branch=master)](https://travis-ci.org/tessel/tessel-av) \n\nUSB Camera, Microphone, Player and Speaker API for Tessel 2\n\n\n#### This module does not and will not support the Tessel 1 Camera Module\n\n\n- Camera, for capturing video streams and still shots\n- Microphone, for sound streaming\n- Player, for sound playback \n- Speaker, for text-to-speech playback\n\n\n```\nnpm install tessel-av\n```\n\n\n## av.Camera\n\nThe `Camera` class produces instances that may be used to capture a still frame or stream frames from a capable USB camera. \n\n\n### av.Camera Initialization\n\n| Property | Type    | Value/Description  | Default  | Required        |\n|----------|---------|--------------------|----------|-----------------|\n| device     | string  | The system path to the video device | `/dev/video0` | no |  \n| dimensions | string  | Valid \"WxH\" dimensions. Is limited to dimensions supported by the device.\\* | `\"800x600\"` | no |\n| fps  | number  | Frames per second. Will be ignored if value is unsupported. | Per camera | no |  \n| port  | number  | Port number for the video server | 8080 | no |  \n| quality  | number  | Set the quality from 0...1 | 1 | no |  \n| fps  | number  | Frames per second. Will be ignored if value is unsupported. | Per camera | no |  \n\n\n\\* The device itself determines what dimensions are supported. Since the output comes directly from the camera hardware, invalid dimensions will be overridden by device if not supported.\n\n\n\n- **`capture`** Take a still frame. Returns a `CaptureStream`, call `pipe` with a destination to send a frame of jpeg encoded data. \n- **`stream`** Stream mjpg frames from camera. \n\n\n### av.Camera Events\n\n- **`data`** when stream has data.\n- **`frame`** when camera has a complete frame.\n\n\n### av.Camera Examples\n\nUse the `data` event to capture a single frame and save it as a JPEG: \n\n```js\nvar fs = require('fs');\nvar path = require('path');\n\nvar av = require('tessel-av');\nvar camera = new av.Camera();\nvar capture = camera.capture();\n\ncapture.on('data', function(data) {\n  fs.writeFile(path.join(__dirname, 'captures/captured-via-data-event.jpg'), data);\n});\n```\n\n\nRespond to an HTTP request by piping the stream returned by `capture()`: \n\n```js\nvar fs = require('fs');\nvar os = require('os');\nvar http = require('http');\nvar port = 8080;\n\nvar av = require('tessel-av');\nvar camera = new av.Camera({\n  width: 320,\n  height: 240,\n});\n\nvar server = http.createServer((request, response) => {\n  response.writeHead(200, { \"Content-Type\": \"image/jpg\" });\n\n  camera.capture().pipe(response);\n\n}).listen(port, () => console.log(`http://${os.hostname()}.local:${port}`));\n\nprocess.on(\"SIGINT\", _ => server.close());\n```\n\n\nA very simple example of direct-to-browser streaming:\n\n```js\nvar express = require('express');\nvar app = express();\nvar server = require('http').Server(app);\nvar os = require('os');\nvar path = require('path');\nvar port = 8888;\n\nvar av = require('tessel-av');\nvar camera = new av.Camera();\n\nserver.listen(port, function () {\n  console.log(`http://${os.hostname()}.local:${port}`);\n});\n\napp.use(express.static(path.join(__dirname, '/public')));\napp.get('/stream', (request, response) => {\n  response.redirect(camera.url);\n});\n```\n\nAnd here's the `public/index.html` file, which should be referenced in a [`.tesselinclude` file](https://tessel.gitbooks.io/t2-docs/content/API/CLI.html)): \n\n```html\n<!doctype html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\">\n    <title>streaming video to img element</title>\n  </head>\n  <body>\n    <img src=\"/stream\">\n  </body>\n</html>\n```\n\n\n## av.Player\n\nThe `Player` class produces instances that may be used to play audio from an mp3 file stored on the Tessel 2.\n\n(Prior to v0.3.0, the `av.Speaker` class was used for audio file playback, and while that still works in versions >=0.3.0, programs will need to update to use this class before 1.0.0 (estimated release: July 1st, 2016)\n\n\n### av.Player Initialization\n\nThe `Player` class constructor accepts one argument, which is optional, that specifies an mp3 file to play when the `play()` method is called. The may be omitted and supplied directly to `play(file [, time])` at a later time in the object's lifecycle.\n\n\n- **`play([seconds])`** Play the specified file. Optionally provide a time to start at in seconds. See Allowed Time String Formats\n- **`play([ file [, seconds])`** Play the specified file. Optionally provide a time to start at in seconds. See Allowed Time String Formats\n- **`play([ 'file.mp3', ...options ])`** Play the file with additional options in an array. \n- **`play(options)`** Play the file with additional options in an object. \n  ```\n  Options {\n    phrase: \"Hello Dave, you're looking well today\", \n    ...\n  }\n  ```\n\n- **`pause()`** Pause playback of the current file. \n- **`stop()`** Stop playback of the current file (calling `play()` will start the playback from the beginning.)\n\n#### Allowed Time String Formats\n\n| Format | Type |\n| ------ | ---- |\n| `hh:mm:ss` | string |\n| `ssss.dddd` | number |\n| `ssss` | number |\n\n\n#### Options\n\nOptions may be _most_ of [options supported by `madplay`](madplay.md). For example, if I wanted to set the amplitude and pitch: \n\n```js\nplayer.play(['foo.mp3', '-a', 10, '-r', 2 ]);\nplayer.play(['foo.mp3', 'a', 10, 'r', 2 ]);\n```\n\nor \n\n```js\nplayer.play({\n  file: 'foo.mp3',\n  a: 10,\n  r: 2,\n});\n```\n\n\n### av.Player Events\n\n- **`ended`** when playback ends.\n- **`play`** after `play()` is called.\n- **`pause`** after `pause()` is called.\n- **`stop`** after `stop()` is called.\n- **`timeupdate`** approximately every 100ms. Delivers an approximation of the playback time in seconds, as `ssss.ddd`.\n\nThe following is an example of the API and events working together: \n\n- The sound will play from the beginning\n- After approximate 2 seconds, the sound will pause\n- After 1 second pause, sound will resume  , it will resume playback from the 10 second mark, play until just after the 12 second mark, where it will stop and then play from the beginning again. \n\n```js\nvar path = require('path');\nvar av = require('tessel-av');\nvar mp3 = path.join(__dirname, '20-second-nonsense.mp3');\nvar sound = new av.Player(mp3);\n\nsound.play();\n\nsound.on('timeupdate', function(seconds) {\n  seconds = Math.round(seconds);\n\n  if (seconds === 2) {\n    this.pause();\n  }\n\n  if (seconds > 12) {\n    this.stop().play();\n  }\n});\n\nsound.on('pause', function() {\n  setTimeout(() => this.play(10), 1000);\n});\n```\n\n\nAlternatively, an mp3 file may be provided at the `play(...)` call site: \n\n```js\nvar path = require('path');\nvar av = require('./lib/index');\nvar mp3 = path.join(__dirname, 'some-audio-file.mp3');\nvar sound = new av.Player();\n\n// Play the mp3, starting at the 10 second mark.\nsound.play(mp3, \"10\");\n\nsound.on('ended', function() {\n  console.log('This is not the end!');\n  sound.play();\n});\n```\n\n\n> Remember that you **must** explicitly specify static assets by listing them in a [`.tesselinclude` file](https://tessel.gitbooks.io/t2-docs/content/API/CLI.html) file. For example, to ensure the `song.mp3` file is deployed to your Tessel 2, you'll create a file called `.tesselinclude` that contains the following:\n> ```\n> song.mp3\n> ```\n> \n> You may find it easier to put all static assets in a sub-directory, such as `public/`, or similar. Then you can include _all_ files and sub-directories by creating a `.tesselinclude` file and listing that assets directory like this: \n> \n> ```\n> public\n> ```\n> \n\n\n## av.Speaker \n\n(Prior to v0.3.0, the `av.Speaker` class was used for audio file playback, and while that still works in versions >=0.3.0, programs will need to update to use this class before 1.0.0 (estimated release: July 1st, 2016)\n\n\n- **`say(\"phrase\")`** Speak the phrase (string). \n- **`say([\"phrase\", ...])`** Speak the phrase with additional options in an array. \n- **`say(options)`** Speak the phrase with additional options in an object. \n  ```\n  Options {\n    phrase: \"Hello Dave, you're looking well today\", \n    ...\n  }\n  ```\n- **`stop()`** Stop playback.\n\n\n### av.Speaker Initialization\n\nOptions may be _most_ of the [options supported by `espeak`](espeak.md). For example, if I wanted to set the amplitude and pitch: \n\n```js\nspeaker.say(['Hello!', '-a', 10, '-p', 50 ]);\nspeaker.say(['Hello!', 'a', 10, 'p', 50 ]);\n```\n\nor \n\n```js\nspeaker.say({\n  phrase: 'Hello!',\n  a: 10,\n  p: 50,\n});\n```\n\n\n#### Queuing\n\nBack to back calls to `speaker.say(...)` will result in each phrase being queued. Once a phrase has been said, the next phrase in the queue will be spoken.\n\n\n### av.Speaker Events\n\n- **`ended`** when speech ends.\n- **`empty`** when speech ends and the speech queue is empty.\n- **`lastword`** when speech ends and the speech queue is empty and the program should **prevent** any further `empty` events from being emitted. This allows your robot to get the last word in without repeating themselves forever.\n- **`say`** after `say()` is called.\n- **`stop`** after `stop()` is called.\n- **`timeupdate`** approximately every 100ms. Delivers an approximation of the speech time in seconds, as `ssss.ddd`.\n\nThe following is an example of the API and events working together: \n\n- The first phrase will be said.\n- Once spoken, the `ended` event will trigger, which will start the \"cycle\" through the letters of the alphabet.\n\n```js\nvar os = require('os');\nvar path = require('path');\nvar av = require('tessel-av');\n\nvar alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\nvar speaker = new av.Speaker();\n\nspeaker.say(`\n  Hello, this is ${os.hostname()}. \n  I'm going to say my A-B-C's now\n`);\n\nspeaker.on('ended', function() {\n  if (alphabet.length) {\n    this.say(alphabet.shift());\n  }\n});\n```\n\nAlternatively, each letter can be \"queued\": \n\n```js\nvar os = require('os');\nvar av = require('tessel-av');\n\nvar alphabet = 'abcdefghijklmnopqrstuvwxyz'.split('');\nvar speaker = new av.Speaker();\n\nspeaker.say(`\n  Hello, this is ${os.hostname()}. \n  I'm going to say my A-B-C's now\n`);\n\nalphabet.forEach(letter => speaker.say(letter));\n\nspeaker.on('lastword', function() {\n  // If this had been an `empty` event, it would've \n  // been emitted again as soon as the next phrase \n  // was spoken.\n  this.say('And now I know my A-B-Cs');\n});\n```\n\n\n## License\n\nMIT.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/tessel/tessel-av.git"
  },
  "scripts": {
    "test": "grunt"
  },
  "version": "0.15.0"
}
